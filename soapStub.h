/* soapStub.h
   Generated by gSOAP 2.8.15 from xml-rpc.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include "xml-rpc-iters.h"      /* deferred for inclusion by C++ compiler */
#include "stdsoap2.h"
#if GSOAP_VERSION != 20815
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

















#ifndef SOAP_TYPE__base64
#define SOAP_TYPE__base64 (29)
/* Base64 schema type: */
struct _base64
{
public:
	_base64();	/* transient */
	_base64(struct soap *_param_1);	/* transient */
	_base64(struct soap *_param_2, int _param_3, unsigned char *_param_4);	/* transient */
	int size() const;	/* transient */
	unsigned char *ptr();	/* transient */
	void size(int _param_5);	/* transient */
	void ptr(unsigned char *_param_6);	/* transient */
	unsigned char *__ptr;
	int __size;
public:
	int soap_type() const { return 29; } /* = unique id SOAP_TYPE__base64 */
};
#endif

#ifndef SOAP_TYPE__rawdata
#define SOAP_TYPE__rawdata (46)
/* Base64 schema type: */
struct _rawdata
{
public:
	_rawdata();	/* transient */
	_rawdata(struct soap *_param_7);	/* transient */
	_rawdata(struct soap *_param_8, int _param_9, char *_param_10);	/* transient */
	_rawdata(struct soap *_param_11, char *_param_12);	/* transient */
	int size() const;	/* transient */
	char *ptr();	/* transient */
	void size(int _param_13);	/* transient */
	void ptr(char *_param_14);	/* transient */
	unsigned char *__ptr;
	int __size;
public:
	int soap_type() const { return 46; } /* = unique id SOAP_TYPE__rawdata */
};
#endif

#ifndef SOAP_TYPE__struct
#define SOAP_TYPE__struct (56)
/* struct */
struct _struct
{
public:
	typedef _struct_iterator iterator;	/* transient */
	typedef _struct_const_iterator const_iterator;	/* transient */
	_struct();	/* transient */
	_struct(const struct _struct &_param_15);	/* transient */
	_struct(struct soap *_param_16);	/* transient */
	_struct(struct soap *_param_17, int _param_18);	/* transient */
	bool empty() const;	/* transient */
	int size() const;	/* transient */
	struct value &operator[](int _param_19) const;	/* transient */
	struct value &operator[](const char *_param_20);	/* transient */
	struct value &operator[](const wchar_t *_param_21);	/* transient */
	const struct value &operator[](const char *_param_22);	/* transient */	/* not serialized */
	const struct value &operator[](const wchar_t *_param_23);	/* transient */	/* not serialized */
	_struct_iterator begin() const;	/* transient */
	_struct_iterator end() const;	/* transient */
	int __size;	/* sequence of elements <member> */
	struct member *member;	/* optional element of type member */
	struct soap *soap;	/* transient */
public:
	int soap_type() const { return 56; } /* = unique id SOAP_TYPE__struct */
};
#endif

#ifndef SOAP_TYPE_data
#define SOAP_TYPE_data (77)
/* data */
struct data
{
public:
	int __size;	/* sequence of elements <value> */
	struct value *value;	/* transient */
public:
	int soap_type() const { return 77; } /* = unique id SOAP_TYPE_data */
};
#endif

#ifndef SOAP_TYPE__array
#define SOAP_TYPE__array (78)
/* array */
struct _array
{
public:
	typedef _array_iterator iterator;	/* transient */
	typedef _array_const_iterator const_iterator;	/* transient */
	_array();	/* transient */
	_array(const struct _array &_param_24);	/* transient */
	_array(struct soap *_param_25);	/* transient */
	_array(struct soap *_param_26, int _param_27);	/* transient */
	bool empty() const;	/* transient */
	int size() const;	/* transient */
	void size(int _param_28);	/* transient */
	struct value &operator[](int _param_29);	/* transient */
	const struct value &operator[](int _param_30);	/* transient */	/* not serialized */
	_array_iterator begin() const;	/* transient */
	_array_iterator end() const;	/* transient */
	struct data data;	/* required element of type data */
	struct soap *soap;	/* transient */
public:
	int soap_type() const { return 78; } /* = unique id SOAP_TYPE__array */
};
#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_value
#define SOAP_TYPE_value (7)
/* Transient type: */
struct value
{
public:
	typedef value_iterator iterator;	/* transient */
	typedef value_const_iterator const_iterator;	/* transient */
	value();	/* transient */
	value(const struct value &_param_31);	/* transient */
	value(struct soap *_param_32);	/* transient */
	value(struct soap *_param_33, bool _param_34);
	value(struct soap *_param_35, int _param_36);	/* transient */
	value(struct soap *_param_37, LONG64 _param_38);	/* transient */
	value(struct soap *_param_39, double _param_40);	/* transient */
	value(struct soap *_param_41, const char *_param_42);	/* transient */
	value(struct soap *_param_43, const std::string &_param_44);	/* transient */
	value(struct soap *_param_45, const wchar_t *_param_46);	/* transient */
	value(struct soap *_param_47, const std::wstring &_param_48);	/* transient */
	value(struct soap *_param_49, ULONG64 _param_50);	/* transient */
	value(struct soap *_param_51, const struct _array &_param_52);	/* transient */
	value(struct soap *_param_53, const struct _struct &_param_54);	/* transient */
	value(struct soap *_param_55, const struct _base64 &_param_56);	/* transient */
	value(struct soap *_param_57, const struct _rawdata &_param_58);	/* transient */
	operator bool() const;	/* transient */
	operator int() const;	/* transient */
	operator LONG64() const;	/* transient */
	operator double() const;	/* transient */
	operator char *() const;	/* transient */
	operator std::string() const;	/* transient */
	operator wchar_t *() const;	/* transient */
	operator std::wstring() const;	/* transient */
	operator ULONG64() const;	/* transient */
	operator struct _array &();	/* transient */
	operator const struct _array &() const;	/* transient */
	operator struct _struct &();	/* transient */
	operator const struct _struct &() const;	/* transient */
	operator struct _base64 &();	/* transient */
	operator const struct _base64 &() const;	/* transient */
	operator struct _rawdata &();	/* transient */
	operator const struct _rawdata &() const;	/* transient */
	struct value &operator[](int _param_59);	/* transient */
	struct value &operator[](const char *_param_60);	/* transient */
	struct value &operator[](const std::string &_param_61);	/* transient */
	struct value &operator[](const wchar_t *_param_62);	/* transient */
	struct value &operator[](const std::wstring &_param_63);	/* transient */
	const struct value &operator[](int _param_64);	/* transient */	/* not serialized */
	const struct value &operator[](const char *_param_65);	/* transient */	/* not serialized */
	const struct value &operator[](const std::string &_param_66);	/* transient */	/* not serialized */
	const struct value &operator[](const wchar_t *_param_67);	/* transient */	/* not serialized */
	const struct value &operator[](const std::wstring &_param_68);	/* transient */	/* not serialized */
	bool operator=(bool _param_69);
	int operator=(int _param_70);	/* transient */
	LONG64 operator=(LONG64 _param_71);	/* transient */
	double operator=(double _param_72);	/* transient */
	ULONG64 operator=(ULONG64 _param_73);	/* transient */
	const char *operator=(const char *_param_74);	/* transient */
	char *operator=(char *_param_75);	/* transient */
	char *operator=(const std::string &_param_76);	/* transient */
	const char *operator=(const wchar_t *_param_77);	/* transient */
	char *operator=(wchar_t *_param_78);	/* transient */
	char *operator=(const std::wstring &_param_79);	/* transient */
	struct _array &operator=(const struct _array &_param_80);	/* transient */
	struct _struct &operator=(const struct _struct &_param_81);	/* transient */
	struct _base64 &operator=(const struct _base64 &_param_82);	/* transient */
	struct _rawdata &operator=(const struct _rawdata &_param_83);	/* transient */
	void size(int _param_84);	/* transient */
	int size() const;	/* transient */
	bool empty() const;	/* transient */
	int nth(int _param_85) const;	/* transient */
	int nth(const char *_param_86) const;	/* transient */
	int nth(const wchar_t *_param_87) const;	/* transient */
	bool has(int _param_88) const;	/* transient */
	bool has(const char *_param_89) const;	/* transient */
	bool has(const wchar_t *_param_90) const;	/* transient */
	bool is_null() const;	/* transient */
	bool is_bool() const;	/* transient */
	bool is_false() const;	/* transient */
	bool is_true() const;	/* transient */
	bool is_int() const;	/* transient */
	bool is_double() const;	/* transient */
	bool is_number() const;	/* transient */
	bool is_string() const;	/* transient */
	bool is_dateTime() const;	/* transient */
	bool is_array() const;	/* transient */
	bool is_struct() const;	/* transient */
	bool is_base64() const;	/* transient */
	bool is_rawdata() const;	/* transient */
	value_iterator begin();	/* transient */
	value_iterator end();	/* transient */
	int __type;	/* any type of element <ref> (defined below) */
	void *ref;	/* transient */
	char *__any;
	struct soap *soap;	/* transient */
};
#endif

#ifndef SOAP_TYPE_member
#define SOAP_TYPE_member (75)
/* member */
struct member
{
public:
	char *name;	/* optional element of type xsd:string */
	struct value value;	/* transient */
public:
	int soap_type() const { return 75; } /* = unique id SOAP_TYPE_member */
};
#endif

#ifndef SOAP_TYPE_params
#define SOAP_TYPE_params (190)
/* params */
struct params
{
public:
	typedef params_iterator iterator;	/* transient */
	typedef params_const_iterator const_iterator;	/* transient */
	params();	/* transient */
	params(struct soap *_param_91);	/* transient */
	params(struct soap *_param_92, int _param_93);	/* transient */
	bool empty() const;	/* transient */
	int size() const;	/* transient */
	struct value &operator[](int _param_94);	/* transient */
	const struct value &operator[](int _param_95);	/* transient */	/* not serialized */
	params_iterator begin() const;	/* transient */
	params_iterator end() const;	/* transient */
	int __size;	/* sequence of elements <param> */
	struct param *param;	/* optional element of type param */
	struct soap *soap;	/* transient */
public:
	int soap_type() const { return 190; } /* = unique id SOAP_TYPE_params */
};
#endif

#ifndef SOAP_TYPE_param
#define SOAP_TYPE_param (200)
/* param */
struct param
{
public:
	struct value value;	/* transient */
public:
	int soap_type() const { return 200; } /* = unique id SOAP_TYPE_param */
};
#endif

#ifndef SOAP_TYPE_methodResponse
#define SOAP_TYPE_methodResponse (202)
/* methodResponse */
struct methodResponse
{
public:
	methodResponse();	/* transient */
	methodResponse(struct soap *_param_96);	/* transient */
	struct value &operator[](int _param_97);	/* transient */
	const struct value &operator[](int _param_98);	/* transient */	/* not serialized */
	struct value &get_fault(void);	/* transient */
	struct value &set_fault(const char *_param_100);	/* transient */
	struct value &set_fault(struct value &_param_101);	/* transient */
	int recv();	/* transient */
	int send();	/* transient */
	struct params *params;	/* optional element of type params */
	struct fault *fault;	/* optional element of type fault */
	struct soap *soap;	/* transient */
public:
	int soap_type() const { return 202; } /* = unique id SOAP_TYPE_methodResponse */
};
#endif

#ifndef SOAP_TYPE_methodCall
#define SOAP_TYPE_methodCall (215)
/* methodCall */
struct methodCall
{
private:
	char *methodEndpoint;	/* not serialized */
	struct methodResponse *methodResponse;	/* not serialized */
public:
	methodCall();	/* transient */
	methodCall(struct soap *_param_102);	/* transient */
	methodCall(struct soap *_param_103, const char *endpoint, const char *methodname);	/* transient */
	struct value &operator[](int _param_104);	/* transient */
	const struct value &operator[](int _param_105);	/* transient */	/* not serialized */
	struct params &operator()();	/* transient */
	struct params &operator()(const struct params &_param_106);	/* transient */
	struct params &response();	/* transient */
	struct value &fault();	/* transient */
	const char *name() const;	/* transient */
	int error() const;	/* transient */
	int recv();	/* transient */
	int send();	/* transient */
	char *methodName;	/* optional element of type xsd:string */
	struct params params;	/* required element of type params */
	struct soap *soap;	/* transient */
public:
	int soap_type() const { return 215; } /* = unique id SOAP_TYPE_methodCall */
};
#endif

#ifndef SOAP_TYPE_fault
#define SOAP_TYPE_fault (213)
/* fault */
struct fault
{
public:
	struct value value;	/* transient */
public:
	int soap_type() const { return 213; } /* = unique id SOAP_TYPE_fault */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (274)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 274; } /* = unique id SOAP_TYPE_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (275)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 275; } /* = unique id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (277)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 277; } /* = unique id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (278)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 278; } /* = unique id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (279)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 279; } /* = unique id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE__boolean
#define SOAP_TYPE__boolean (21)
typedef char _boolean;
#endif

#ifndef SOAP_TYPE__double
#define SOAP_TYPE__double (23)
typedef double _double;
#endif

#ifndef SOAP_TYPE__i4
#define SOAP_TYPE__i4 (24)
typedef int _i4;
#endif

#ifndef SOAP_TYPE__int
#define SOAP_TYPE__int (26)
typedef LONG64 _int;
#endif

#ifndef SOAP_TYPE__string
#define SOAP_TYPE__string (27)
typedef char *_string;
#endif

#ifndef SOAP_TYPE__dateTime_DOTiso8601
#define SOAP_TYPE__dateTime_DOTiso8601 (28)
typedef char *_dateTime_DOTiso8601;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


extern struct value *new_value(struct soap *soap);

extern struct value *init_value(struct soap *soap, struct value *v);

extern char *bool_of(struct value *v);

extern LONG64 *int_of(struct value *v);

extern double *double_of(struct value *v);

extern const char **string_of(struct value *v);

extern const char **dateTime_of(struct value *v);

extern struct _base64 *base64_of(struct value *v);

extern struct _rawdata *rawdata_of(struct value *v);

extern struct value *value_at(struct value *v, const char *s);

extern struct value *value_atw(struct value *v, const wchar_t *s);

extern int nth_at(const struct value *v, const char *s);

extern int nth_atw(const struct value *v, const wchar_t *s);

extern int nth_nth(const struct value *v, int n);

extern struct member *nth_member(struct value *v, int n);

extern struct value *nth_value(struct value *v, int n);

extern char is_null(const struct value *v);

extern char is_int(const struct value *v);

extern char is_double(const struct value *v);

extern char is_number(const struct value *v);

extern char is_string(const struct value *v);

extern char is_bool(const struct value *v);

extern char is_true(const struct value *v);

extern char is_false(const struct value *v);

extern char is_array(const struct value *v);

extern char is_struct(const struct value *v);

extern char is_dateTime(const struct value *v);

extern char is_base64(const struct value *v);

extern char is_rawdata(const struct value *v);

extern void set_struct(struct value *v);

extern void set_size(struct value *v, int n);

extern int has_size(const struct value *v);

extern int is_empty(const struct value *v);

extern struct params *new_params(struct soap *soap);

extern struct params *init_params(struct soap *soap, struct params *p);

extern struct value *nth_param(struct params *p, int n);

extern int call_method(struct soap *soap, const char *endpoint, const char *methodName, struct params *p, struct methodResponse *r);

#endif

/* End of soapStub.h */
